				Node.js
.....................................................................................

1.Core Node.js
2.npm fundamentals
3.Express.js
4.ORM integration/Database Programming


Core Node.js
.............

1.What is Node.js
2.Why Node.js
3.High level and low level architecture of Node.js
4.Node.js coding part

What is Node.js?
  Node.js js runtime env and platform to build js apps.


JS Runtime:

 where js apps/code to be executed.

places of js runtime

1.browser
   Every web browser has embedded js runtime.

 Every js runtime is different with respect to implementation but all js engine executes the code in similar way.
 every js engine implements the "ECMA" specification.

			ECMA Spec 
			   |
	-------------------------------------------------
	|              |                |        |
    Microsoft Edge  google chrome     Firefox   Opera
      Chakra           v8	   Spider Monkey

2.Standalone js engine
  Google only released first standalone js engine called v8 , also first open source js engine.
  based on v8 js engine only node.js was created.


What you can do with node.js? why node.js?
  
    Node was created to build non blocking io (network applications) applications

IO:
1.Blocking io
2.Non blocking io
3.IO and multi threading.

Why Node.js?
   NonBlocking IO:

in order to understand nonblocking io, we can take a look at how webserver works.

IO At low level:
..................

Every programming language offers api to talk to io channels, like reading data from disk,keyword,showing output in screen,sending data to network.

Without help of os , we cant perform any io operations.

		    language api
			|
		    os api  - system call
         		|
		    OS kernal -os low level layer
			|	 			
			|
		   os kernal program- file descriptor -c
			|
		 hard ware layer (hdd,Network card,monitor,keyboard)


Every file descriptor is just simple c program.
Every file descriptor program is made up of data structure called "array".

File descriptor is initalized when a process is created for eg, when you start notepad or powerpoint, when you start web server.

File descriptor is intialized with three entries.

Since fd is array , which is initalized with index base.

fd is always initalized with 3 entries

 index   Reference Pointer   Device
  0       STDIN              keyword
  1       STDOUT             Monitor
  2       STDERR             Monitor

Lets assume in the program we try to read file content or write file content into disk.

for eg in the code
    fs.read('path')

....................................................................................
			 Web server design and io
.....................................................................................

Web server is simple io program which reads and writes.

reads means request,writes means response.

web server receive request, webserver sends/writes response.


Every request is treated as io request.

How web server handles each each request?
   Every request is mapped against a single thread.
   Request per thread model

if 100 request, there would be 100 threads.

if 1000 request, we require 1000 threads
    
.....................................................................................
			Non blocking api

linux operating introduced first non blocking api
called select
in order to read data process used "receive/read" blocking api 
select + read 

select and read is initally good but not good in large scale so that new api was addeded is poll api.

Poll api was introduced to simplify the communication between kernal and process using event driven programming architecture.

Poll api had some limitation , so finally new api was introduced called "epoll"

...................................................................................
			C10 k problem, and Linux implemnetation
...................................................................................

Ngnix is the first non blocking webserver which was implemented in 2002 to 2003 in linux.

After success of linux operating system, other os Vendors started giving wrappers

Microsoft windows - iocp
Mac - Kqueue
unix and other bsd os - Kqueue.
linux - epoll

Now a days we use epoll, kqueue,iocp
.....................................................................................
			  Node.js and Nonblocking io
....................................................................................
Node.js was created based on nginx server in 2007.

The first programmable non blocking io arch is node.js.

Nodejs was created with two components

1.v8 
2.libuv
....................................................................................
			 libuv threading model
....................................................................................

node.js is multi threaded.

node.js libuv provides two types of threads

1.event loop thread - non blocking io threads
     This thread is responsible for handling non blocking io calls primerly networking io like web,sockets,udp...
  Per node process only one event loop thread is available

2.worker poll threads- blocking threads 
    This thread is responsible for handling blocking operations and some time non blocking file io operations
..............................................................................................

Programming:

1.Node module patterns
2.Types of modules
  2.1.core modules
3.npm fundamentals
4.Frameworks - Express.js


1.Node REPL
2.Node and js apis
3.Node core apis
4.Styles of writing async programming
   ->Callback pattern
   ->Promise Pattern
   ->Promise with Async and await Pattern


...................................................................................

1.Node REPL - Read Evaluate Print loop

Node REPL is used to run js programs interactive mode.

Js programs are executed in two modes

1.interactive mode - REPL mode
2.script mode - by loading script on to the runtime


....................................................................................
			node.js and js apis

node supports all js apis except browser specific apis

like window,document,sessionStorage etc...

> window
Uncaught ReferenceError: window is not defined
> document
Uncaught ReferenceError: document is not defined
>

in js , in browser "Window" super object.

in js, in node js, "Process" is super object

Process:
........
 It gives information about node.js platform.

.................................................................................
			 How to write non blocking apps
...................................................................................

Fundamental Requirement:
........................

1.OS should support non blocking apis like select, poll,epoll, iocp, kqueue

2.Program languages/platforms also should provide high level apis to map os low level apis

3.In order to write non blocking apps in js(node), we have different patterns(styles)

Nonblocking Applications Development style:
............................................

1.callbacks
2.Promises
3.Promise with Async await
4.reactive programming -rxjs


1.callbacks:
  Callback is listener function which gets registered during compile time
  and executed during runtime when ever the event is emitted.


Req for async programming:
 
1.You need high level non blocking api - provided by node.js 
2.listener api which is called "function as parameter/hof" 

HOF functions are becoming listeners/callbacks which are called when ever event is emitted.


NonBlocking apis:
1.timer
   -setTimeout
   -setInterval
2.io
   web
   fs
   socket
 etc...
3.process api
  nextTick
....................................................................................
			Higher order function
....................................................................................
function blockMe(message) {
    console.log(message)
}

function delay(callback) {
    callback()
}

function main() {
    blockMe('start')
    delay(function () {
        console.log('hello')
    })
    blockMe('end')
}
main()


...................................................................................
			How to implement non blocking using timers
...................................................................................
function blockMe(message) {
    console.log(message)
}

function delay(callback) {
    setTimeout(callback, 5000)
}

function main() {
    blockMe('start')
    delay(function () {
        console.log('hello')
    })
    blockMe('end')
}
main()
.....................................................................................
			How to pass data from non blocking api to listener
.....................................................................................
function blockMe(message) {
    console.log(message)
}

function delay(callback) {
    setTimeout(callback, 5000, 'hello')
}

function main() {
    blockMe('start')
    delay(function (message) {
        console.log(message)
    })
    blockMe('end')
}
main()
....................................................................................

callbacks with arrow:

const blockMe = (message) => console.log(message)

const sayHello = hello => setTimeout(hello, 5000, 'Hello!!')

blockMe('start')
sayHello(message => console.log(message))
blockMe('end')
.....................................................................................
			complex callbacks with biz logic:
.....................................................................................

How to handle success and failures?


const login = (userName, password, resolve, reject) => {
    if (userName === 'admin' && password === 'admin') {
        setTimeout(resolve, 100, 'Login success')
    } else {
        setTimeout(reject, 100, 'Login failed')
    }
}


function main() {
    login('admin', 'admin', (success) => {
        console.log(success)
    }, (err) => {
        console.log(err)
    })

    login('ddd', 'xxx', (success) => {
        console.log(success)
    }, (err) => {
        console.log(err)
    })
}
main()
.....................................................................................
  			Nested Callbacks
.................................................................................

The output of one callback will be input into another callback -  async composition.

//nested callback or async composition.
//the out put of one callback would be input to another callback.

//getUser ---> login ----> showDashboard

const getUser = (resolve, reject) => {
    console.log('getUser is called')
    let user = {
        name: 'admin'
    }
    //failure
    //user = null 
    if (user) {
        setTimeout(resolve, 100, user)
    } else {
        setTimeout(reject, 100, 'User Not found')
    }
}
const login = (user, resolve, reject) => {
    console.log('login is called')
    if (user.name === 'admin') {
        setTimeout(resolve, 100, 'login success')
    } else {
        setTimeout(reject, 100, 'login is failed')
    }

}
const showDashboard = (status, resolve, reject) => {
    console.log('showDashboard is called')
    if (status === 'login success') {
        setTimeout(resolve, 100, 'welcome to admin')
    } else {
        setTimeout(reject, 100, 'welcome to guest')
    }
}


function main() {
    getUser((user) => {
        login(user, (status) => {
            showDashboard(status, (page) => {
                console.log(page)
            }, (err) => {
                console.log(err)
            })
        }, (err) => {
            console.log(err)
        })
    }, (err) => {
        console.log(err)
    })
}
main()
....................................................................................
				Callback Hell
....................................................................................

function main() {
    getUser(user => {
        login(user, status => {
            showDashboard(status, (page) => {
                console.log(page)
            }, (err) => {
                console.log(err)
            })
        }, err => {
            console.log(err)
        })
    }, err => {
        console.log(err)
    })

}
main()

Questions:

1.Whether this code is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintainable?

No
fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})
Callback Hell:

 -It is not bug or error in code
 -It is way of writing callback based program
 -Callback based non blocking programming hard to understand, maintain, debug, scale Which   called as "Callback Hell".


How to write better async/non blocking code without callbacks?

-Generally without callbacks not possible to write async/non blocking code.
-Rather we can abstract complexity of writing callbacks.

....................................................................................
			  Promises
...................................................................................

In 2005, JQUERY team started with working complex callback patterns, they found callback hell problem.

They proposed a  Design pattern to write better callback programming(Async) programming.

  "Promise".

Promise is design pattern which hides complexity of callback patterns

Since Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks

In order standardize , ECMA committee decided to include Promise Design pattern at language level .(ES 6)
2012 E6 Committee introduced promise design pattern  as  "Promise" Object  in JavaScript.

.....................................................................................
		  Promise Design pattern Implementation in ES 6
.....................................................................................

Features of Promise Object:
1.Promise by default is Async. Which implements timer api with 0 ms .
2.Promise can be used with any async callback based  implementations.

Objective:

 To remove callbacks in async/non blocking code. write cleaner async programming.
 To remove complex callback chaining code.

Difference between callbacks and promises:

Essentially, a promise is a returned object to which you attach callbacks, instead of passing callbacks into a function.
....................................................................................

		Promise Implementation: Object  creations
...................................................................................

1. Create Promise Object from Promise constructor
      new Promise()
2. Create Promise object from factory apis 
      Promise.resolve() / Promise.reject()

Promise object methods:

1.then - success
2.catch - errors
3.finally - clean up

factory api to create Promise object
4.resolve
5.reject
.......................................
6.all
7.race

1.Promise factory api
   -success - resolve
   -failure - reject

//basic promise implementation:
//In promises , you don't need to pass function as parameter

Promise with Success and also ensure that Promise is async.

//basic promise implementation:
//In promises , you dont need to pass function as parameter

Promise with Success and also ensure that Promise is async.


function blockMe(message) {
    console.log(message)
}

function getValue() {
    return Promise.resolve(10)
}


function main() {
    blockMe('start')
    getValue().then(value => {
        console.log(value)
    })
    blockMe('end')
}
main()
///

Promise With error:

function blockMe(message) {
    console.log(message)
}

function getError() {
    return Promise.reject('something went wrong')
}


function main() {
    blockMe('start')
    getError().catch(err => {
        console.log(err)
    })
    blockMe('end')
}
main()

Promise with success and failure: with biz logic.



function login(userName, password) {
    if (userName === 'admin' && password === 'admin') {
        return Promise.resolve('login success')
    } else {
        return Promise.reject('login is failed')
    }
}


function main() {
    login('admin', 'admin')
        .then(status => {
            console.log(status)
        }).catch(err => {
            console.log(err)
        })
    login('xxx', 'yy')
        .then(status => {
            console.log(status)
        }).catch(err => {
            console.log(err)
        })
}
main()


2.Promise Constructor Api
.........................

i want to return users after 1000ms
if i want to wrap any existing callback based program into promise based 

              "You have to use Promise Constructor Pattern"


Promise with value:

function getValue() {
    return new Promise((resolve, reject) => {
        setTimeout(resolve, 1000, 10)
    })
}



function main() {
    getValue().then(value => console.log(value))
}
main()

Promise with biz logic:
.....................

function login(userName, password) {
    return new Promise((resolve, reject) => {
        if (userName === 'admin' && password === 'admin') {
            setTimeout(resolve, 1000, 'login success')
        } else {
            setTimeout(reject, 1000, 'login failed')
        }
    })
}



function main() {
    login('admin','admin')
        .then(status => console.log(status))
        .catch(err => {
            console.log(err)
        })
}
main()
....................................................................................
			Callback hell and promises
.....................................................................................

const getUser = () => {
    console.log('getUser is called')
    return new Promise((resolve, reject) => {
        let user = {
            name: 'admin'
        }
        //failure
        //user = null 
        if (user) {
            setTimeout(resolve, 100, user)
        } else {
            setTimeout(reject, 100, 'User Not found')
        }
    })
}
const login = user => {
    console.log('login is called')
    return new Promise((resolve, reject) => {
        if (user.name === 'admin') {
            setTimeout(resolve, 100, 'login success')
        } else {
            setTimeout(reject, 100, 'login is failed')
        }
    })

}
const showDashboard = status => {
    console.log('showDashboard is called')
    return new Promise((resolve, reject) => {
        if (status === 'login success') {
            setTimeout(resolve, 100, 'welcome to admin')
        } else {
            setTimeout(reject, 100, 'welcome to guest')
        }
    })
}


function main() {
    // getUser((user) => {
    //     login(user, (status) => {
    //         showDashboard(status, (page) => {
    //             console.log(page)
    //         }, (err) => {
    //             console.log(err)
    //         })
    //     }, (err) => {
    //         console.log(err)
    //     })
    // }, (err) => {
    //     console.log(err)
    // })


    //with promise chaining
    // getUser()
    //     .then(user => {
    //         login(user).then(status => {
    //             showDashboard(status).then(page => {
    //                 console.log(page)
    //             }).catch(err => console.log(err))
    //         }).catch(err => {
    //             console.log(err)
    //         })
    //     })
    //     .catch(err => console.log(err))

    // getUser()
    //     .then(user => {
    //         return login(user)
    //     })
    //     .then(status => {
    //         return showDashboard(status)
    //     })
    //     .then(page => {
    //         console.log(page)
    //     })
    //     .catch(err => console.log(err))

    // getUser()
    //     .then(user => login(user))
    //     .then(status => showDashboard(status))
    //     .then(page => console.log(page))
    //     .catch(err => console.log(err))

    const { log } = console
    getUser()
        .then(login)
        .then(showDashboard)
        .then(log)
        .catch(log)

}
main()
.....................................................................................
				Promise Hell
.....................................................................................

const getUser = () => {
    console.log('getUser is called')
    return new Promise((resolve, reject) => {
        let user = {
            name: 'admin'
        }
        //  user = null
        if (user) {
            setTimeout(resolve, 1000, user)
        } else {
            setTimeout(reject, 1000, { message: 'User not found' })
        }
    })
}
const login = (user) => {
    console.log('login is called')
    return new Promise((resolve, reject) => {
        if (user.name === 'admin') {
            setTimeout(resolve, 1000, 'login success')
        } else {
            setTimeout(reject, 1000, 'login failed')
        }
    })
}
const showDashboard = (status) => {
    console.log('showDashboard is called')
    return new Promise((resolve, reject) => {
        if (status === 'login success') {
            setTimeout(resolve, 1000, 'Welcome to dashboard')
        } else {
            setTimeout(reject, 1000, 'Sorry Try again')
        }
    })
}


function main() {
      getUser()
        .then(user => login(user))
        .then(status => showDashboard(status))
        .then(page => console.log(page))
        .catch(err => console.log(err))

}
main()
Here we have so many "thens" or "thenables".

In order reduce thenables, ES 7 Introduced new key words to abstract promise then and catch are "async and await"

async keyword:

1.in front of function we use async keyword, meaning that the function returns promise by default with success only.



// function getValue() {
//     return 10
// }

// function getValue() {
//     return Promise.resolve(10)
// }

async function getValue() {
    return 10  // Promise.resolve(10)
}

function main() {
    const value = getValue()
    console.log(value)
    value.then(res => console.log(res))
}
main()

await:
   to resolve promise without using then and catch methods.
   await makes promise code like normal sync code
 

async function login(userName, password) {
    if (userName === 'admin' && password === 'admin') {
        return 'login success'
    } else {
        return Promise.reject('login is failed')
    }
}

async function main() {
    try {
        const status = await login('admin','admin')
        console.log(status)
    }
    catch (err) {
        console.log(err)
    }
}
main()
.................

Promise chaining with async and await keyword
const getUser = () => {
    console.log('getUser is called')
    return new Promise((resolve, reject) => {
        let user = {
            name: 'admin'
        }
        //failure
        //user = null 
        if (user) {
            setTimeout(resolve, 100, user)
        } else {
            setTimeout(reject, 100, 'User Not found')
        }
    })
}
const login = user => {
    console.log('login is called')
    return new Promise((resolve, reject) => {
        if (user.name === 'admin') {
            setTimeout(resolve, 100, 'login success')
        } else {
            setTimeout(reject, 100, 'login is failed')
        }
    })

}
const showDashboard = status => {
    console.log('showDashboard is called')
    return new Promise((resolve, reject) => {
        if (status === 'login success') {
            setTimeout(resolve, 100, 'welcome to admin')
        } else {
            setTimeout(reject, 100, 'welcome to guest')
        }
    })
}


async function main() {
    try {
        const user = await getUser()
        const status = await login(user)
        const page = await showDashboard(status)
        console.log(user,status,page)  
    }
    catch (err) {
        console.log(err)
    }
}
main()
.....................................................................................
			Types of modules
.....................................................................................

1.Custom module
   built by us
2.built in modules
   provided by node.js  
3.provided by third party/community
  libs,frameworks

.......................................................................................
				Modules Pattern
			       (Custom Module)
...................................................................................

CommonJs:
 It is one the module pattern , introduced in 2006, node adopted commonjs as default module pattern.
 node provides commonjs implementation by default.

You can write node apps using es6 module pattern as well.

How to share code? How to import code?

 Code:
  Could be variables, functions, classes.
  Variables can have any literal string,numbers,boolean,objects,functions...

How to share code? How to import code?

 Code:
  Could be variables,functions,classes.
  Variables can have any literal string,numbers,boolean,objects,functions...

src
  |
  subfolders
|
index.js

Sharing code :

Keywords
exports
module.exports

Importing code:

require('fileName')
require('folderName/fileName')

exports:
 Used to share more code from the single file.
 exports packs the entire code into one single js object and returns that object

//pack the code 
exports.firstName = 'Subramanian'
exports.lastName = 'Murugan'
exports.salary = 1000
exports.status = true
exports.address = {
    city: 'Coimbatore'
}
exports.skills = ['Java','JavaScript','Node.js']


require:
  It is a function which returns what ever we exported from the file.

const obj= require('fileName')



src/util.myutil.js

//pack the code 
exports.firstName = 'Subramanian'
exports.lastName = 'Murugan'
exports.salary = 1000
exports.status = true
exports.address = {
    city: 'Coimbatore'
}
exports.skills = ['Java', 'JavaScript', 'Node.js']
exports.saySomething = () => "something"

src/index.js
//access the code from the myutil.js 
const res = require('./util/myutil')
console.log(res)

console.log(`${res.firstName} ${res.lastName} ${res.address.city} ${res.salary}`)
console.log(`${res.skills} ${res.status} ${res.saySomething()}`)

node src/index.js
{
  firstName: 'Subramanian',
  lastName: 'Murugan',
  salary: 1000,
  status: true,
  address: { city: 'Coimbatore' },
  skills: [ 'Java', 'JavaScript', 'Node.js' ],
  saySomething: [Function (anonymous)]
}
Subramanian Murugan Coimbatore 1000
Java,JavaScript,Node.js true something
....................................................................................
				module.exports
....................................................................................

Export only one item from the file.

eg"
 if you want to share  "Class"
 if you want to share "array"
 if you want to share "object"



src/services/todo.service.js

class TodoService {
    constructor() {

    }
    //biz apis
    save() {
        return 'save'
    }
    findAll() {
        return 'findAll'
    }
    find() {
        return 'find'
    }
    remove() {
        return 'remove'
    }
}
// module.exports = TodoService

//return object 
module.exports = new TodoService()


src/index.js
// const TodoService = require('./services/todo.service')
const todoService = require('./services/todo.service')

// let service = new TodoService()

// console.log(service.save())
// console.log(service.findAll())

console.log(todoService.save())
console.log(todoService.findAll())

.................................................................................
				 Returning data
.................................................................................

src/mockdata/todo.mock.js


const TODOS = require('../mockdata/todo')
class TodoService {
    constructor() {

    }
    //biz apis
    save() {
        return 'save'
    }
    findAll() {
        return TODOS
    }
    find() {
        return 'find'
    }
    remove() {
        return 'remove'
    }
}
// module.exports = TodoService

//return object 
module.exports = new TodoService()

src/index.js
// const TodoService = require('./services/todo.service')
const todoService = require('./services/todo.service')

// let service = new TodoService()

// console.log(service.save())
// console.log(service.findAll())

console.log(todoService.save())
console.log(todoService.findAll())

How to use es6 module inside node?

Before node 16, there was no direct support of es6 modules, now we can run es6 modules code inside node with some configuration.

src/lib/mylib.js
export const firstName = 'Subramanian'
export const lastName = 'Murugan'

src/index.js
import { firstName,lastName } from "./lib/mylib.js";

console.log(firstName,lastName)

>node src/index.js
Subramanian Murugan

Mixing commonjs and es 6 module:
src/lib/todo.service.js
class TodoService {
    findAll() {
        return ["done"]
    }
}
module.exports = new TodoService()

src/index.js
import { firstName, lastName } from "./lib/mylib.js";
import pkg from './lib/todo.service.js';
const { findAll } = pkg;

console.log(firstName, lastName)
console.log(findAll())
.............................................................................................
Built in Node.js Modules:
.........................
https://nodejs.org/docs/latest/api/

Built in node modules provides

1.non blocking networking io apis
   -tcp,http,datagram etc...
2.timers
3.file system api
   to read and write data into disk files
4.common apis
   os,events


Common apis:

1.OS
const os = require('node:os')

function main(){
    console.log(os.arch())
    console.log(os.cpus())
}
main()

2.Events:
import { EventEmitter } from 'node:events'

//custom event driven programming
//to register listener we have "on" method, to emit event we have "emit method"

class Sales extends EventEmitter {
    constructor() {
        super()
        this.on('onsold', (evt) => {
            console.log(evt)
        })
    }
    sale(product) {
        this.emit('onsold', product)
    }
}
function main() {
    let sales = new Sales()
    sales.sale({ id: 1, name: 'product1' })
}
main()
............................................................................................
				Web Applications in Node
...........................................................................................

.....................................................................................
			HTTP programming
....................................................................................
Node was created to build non blocking web server and web applications.
Node provides single event loop thread which handles lot of concurrent http requests.
Node offers high level http wrapper apis to talk to os apis.
Node offers http as object.

HTTP Objects

1.Agent -  http.Agent
  For handling connections between and server

2.ClientRequest - http.clientRequest
  For creating http clients

3.Server - http.Server
  For creating web servers,we can create app and deploy on top of server.
  
4.ServerResponse - http.ServerResponse
  ServerResponse is outputstream of "http socket"

5.IncomingMessage -http.IncomingMessage
    The payload which is sent by client -  Message

6.OutgoingMessage -http.OutgoingMessage
    The data which is sent by server - Message

7.Global Methods of http
  
 1.createServer
    factory method to create http server instance.
HTTP events:
 
 There are three types of events

1.HTTP Request events
  Which are triggered whenever client request is recived by server

request.on('nameoftheevent',listner)

2.Http Response events
   Which are triggered whenever server response is sent by server

response.on('nameoftheevent',listner)

3.Server Events
   Server events are triggered during server startup,connection,handshake,request

 server.on('nameoftheevent',listner)

common events:
data,close,end,error

Note:
 Each Object has its own events apart from common events.

/////////////////////////////////////////////////////////////////////////////////////


First Web Server: Helloworld
//simple web server
const http = require('node:http')

//create Http Server
const server = http.createServer((request, response) => {
    //write code to handle request and response
    response.write('Hello')
    //close the stream
    response.end()
})


//start the server
server.listen(3000, () => {
    console.log('server is ready')
})

How to attach Events?
request,response,server.

//simple web server
const http = require('node:http')

//create Http Server
const server = http.createServer((request, response) => {
    //write code to handle request and response
    response.write('Hello')
    //close the stream
    response.end()
})


//start the server
server.listen(3000, () => {
    console.log('server is ready')
})

//attach server listener
server.on('request', (request, response) => {
    console.log(`Request received on ${new Date()} URL ${request.url} method ${request.method}`)
})
...................................................................................
			  How to send json payload 
.....................................................................................

const http = require('node:http')

const server = http.createServer((request, response) => {
    const data = [{ id: 1, name: 'Subramanian' }, { id: 2, name: 'Ram' }]
    const jsonData = JSON.stringify(data)
    //set content type
    response.writeHead(200, {
        'Content-Type': 'application/json'
    })
    response.write(jsonData)
    response.end()
})

//start the server
server.listen(3000, () => {
    console.log('server is ready')
})
.....................................................................................
			Module driven web app with sync and async
.....................................................................................

src/services/user.service.js
const USERS = require('../mock-data/users')

class UserService {
    constructor() {

    }
    //sync api
    findAll() {
        return USERS;
    }
    //async api -  using Promises
    findAllAsync() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, USERS)
        })
    }
}
module.exports = new UserService()

src/index.js
const http = require('node:http')
const { findAll } = require('./services/user.service')

// const server = http.createServer((request, response) => {
//     const data = findAll()
//     const jsonData = JSON.stringify(data)
//     //set content type
//     response.writeHead(200, {
//         'Content-Type': 'application/json'
//     })
//     response.write(jsonData)
//     response.end()
// })
const server = http.createServer(async (request, response) => {
    try {
        response.writeHead(200, {
            'Content-Type': 'application/json'
        })
        const data = await findAll()
        const jsonData = JSON.stringify(data)
        response.end(jsonData)
    }
    catch (err) {
        response.writeHead(500, {
            'Content-Type': 'application/json'
        })
        response.end({ err: err })
    }
})
//start the server
server.listen(3000, () => {
    console.log('server is ready')
})
....................................................................................
			How to pass data to server
....................................................................................
src/services/user.service.js
const USERS = require('../mock-data/users')

class UserService {
    constructor() {

    }
    //sync api
    findAll() {
        return USERS;
    }
    //async api -  using Promises
    findAllAsync() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, USERS)
        })
    }
    save(user) {
        console.log(user)
    }
}
module.exports = new UserService()

src/index.js
const http = require('node:http')
const { save } = require('./services/user.service')

const server = http.createServer((request, response) => {
    //get input
    let data = ''
    request.on('data', (chunk) => {
        data += chunk
    })
    request.on('end', () => {
        //call save method
        save(JSON.parse(data))
        response.end('save')
    })
})
//start the server
server.listen(3000, () => {
    console.log('server is ready')
})

...................................................................................
				NPM
.....................................................................................
What is npm?
 npm is the world's largest software registry.
 open source developers from every part of the world use npm to share and borrow packages.
 many organizations use npm to manage private development as well.

In js, you might have created lib/framework/utility, if you want to share to other developers in the world or within your organization or your team - npm helps.


NPM consists of three components

1.the website - used to discover packages, setup profiles and manage other aspects of npm -https://www.npmjs.com/

2.CLI runs from the terminal, and how most developers interact with npm.
  npm is cli name/command , which is distributed alone node.js itself

3.registry - it is  large public database of js software and the meta information surrounding it.

core concepts in npm:

1.package
2.module

What is package?
   A package is a "file or directory" that is described by a "package.json" file

   A package must contain package.json file in order to be published to the npm    registry


Modules:
  A module is any "file or directory" in the "node_modules" directory that can be loaded by the node.js require function.

 A JavaScript file
...................................................................................
				NPM
.....................................................................................

What is npm?
 npm is the world's largest software registry.
 open source developers from every part of the world use npm to share and borrow packages.
 many organizations use npm to manage private development as well.

In js, you might have created lib/framework/utility, if you want to share to other developers in the world or within your organization or your team - npm helps.


NPM consists of three components

1.the website - used to discover packages, setup profiles and manage other aspects of npm -https://www.npmjs.com/

2.CLI runs from the terminal, and how most developers interact with npm.
  npm is cli name/command , which is distributed alone node.js itself

3.registry - it is  large public database of js software and the meta information surrounding it.

core concepts in npm:

1.package
2.module

What is package?
   A package is a "file or directory" that is described by a "package.json" file

   A package must contain package.json file in order to be published to the npm    registry


Modules:
  A module is any "file or directory" in the "node_modules" directory that can be loaded by the node.js require function.

 A JavaScript file
....
....................................................................................
				How to create npm package
....................................................................................

package.json

=>It is file which describes about your project/app/file/directory.

i have created a project like

myapp/src/util/lib.js

class A{}

module.exports = new A()

myapp/src/util/index.js
const A= require('./util/lib.js')

Can you call this project as "package"

No
Because this project does not contain "package.json",Which are called module
...................................................................................

i have created a project like

myapp/src/util/lib.js

class A{}

module.exports = new A()

myapp/src/util/index.js
const A= require('./util/lib.js')

myapp/package.json


Can you call this project as "package"

Yes

Why package.json?

=>if package.json is there, only we can transfer/share to other developers via "npm registry"

Note:
 Every js project must have package.json file

Steps:

1.create folder
>mkdir mynpm-apps
>cd mynpm-apps
>mkdir src

2.create package.json

Before create you have to ensure that npm has been installed.

npm init <initalizer>

npm init
This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.

See `npm help init` for definitive documentation on these fields
and exactly what they do.

package.json

{
  "name": "mynpmapps",
  "version": "1.0.0",
  "description": "This is demo package",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "my",
    "demo",
    "package"
  ],
  "author": "Subramanian Murugan",
  "license": "ISC"
}
name:
 This is used to publish package into registry

version:
   if you publish package into registry, which is differentiated by "version"

"1.0.0" - version no is based on the concept called "SEM Ver" concept- Semantic versioning.
 Major.minor.patch

main:
  It is main file used /entry file in the package , generally it would index.js or main.js

description:
  It explains the nature of packages- what is this packge.

Keywords:
  Used to discover your packages using npm search command

author:
  Who is author of this package

license:
  You should specify a license for your package so that people know how they are permitted to use it.
....................................................................................
				Node Packages

How to install node packages which was distributed by others?

npm install [<package-name>]
npm i [<package-name>]

npm i [<package-name>] --options


Options:

 --save
     for production + dev
 --save-dev
     -for only for dev 
 --production
    -for only production
  -g
    -for tool purpose -dev

No options are given by default "--save"

if you want to use any lib

Steps;
1.ensure that package.json is created or not - one time
2.npm i packageName --options
3.after installing you can verify , the node_modules folder is created and installed
  libs inside that folder.
  You have to verify package.json as well, there is one entry is added

  "dependencies": {
    "lodash": "^4.17.21"
  }


3.How to use package inside our code?
  Using cjs or es6 module.

//i want to use lodash lib
const _ = require('lodash')

//start using lib

function main() {
    const res = _.partition([1, 2, 3, 4], n => n % 2);
    console.log(res)
}
main()

Application mode

1.dev
2.test
3.prod

dev : any dependency required for development only
  --save-dev
test : 
   any dependency required for development only - test
   --save-dev
prod:
  dependency used in dev and production... 
  --save
"dependencies": {
    "lodash": "^4.17.21"
  }

..................................................................................
			 Test /Dev Only Dependency
.................................................................................

Libs required for dev and test

tools
   -compilers, webservers
   -testing libs and frameworks 

eg:
  mocha - test runner is used for running test case
  chai.js -test assertion lib used for writing test cases
  jest -  test runner is used for running test cases

how to install chai?

G:\Marsh\nodejs\mynpm-apps>npm i chai --save-dev

added 7 packages, and audited 9 packages in 2s

found 0 vulnerabilities

 "devDependencies": {
    "chai": "^5.1.1",
    "mocha": "^10.7.3"
  }
.....................................................................................
.....................................................................................
			How to prepare your app for production
.....................................................................................

When you upload the app into source code repository like "github/bitbucket" , we never upload node_modules folder.

Steps for Testing:

1.just delete node_modules folder

2.open command prompt

3.create production app

npm install --production
  it scans package.json which install only from  production dependencies
or
npm install --omit=dev
  it scans package.json which install only from  production dependencies			
....................................................................................
		How to install all dependencies 
....................................................................................
mynpm-apps>npm i
.....................................................................................
,,,,,,,,,,,,,........................................................................
			  Global Packages
....................................................................................
Global package is installed not inside project, installed globally.
Global packages are generally tools to create projects ,webservers, test runtime like so.

nodemon:
  nodemon is a tool that helps develop Node.js based applications by automatically restarting the node application when file changes in the directory are detected.
 
npm install nodemon -g

global modules are available like executable files

How to test?

mynpm-apps>nodemon --help
  Usage: nodemon [options] [script.js] [args]

  Options:

  --config file ............ alternate nodemon.json config file to use
  -e, --ext ................ extensions to look for, ie. js,pug,hbs.
  -x, --exec app ........... execute script with "app", ie. -x "python -v".
  -w, --watch path ......... watch directory "path" or files. use once for
                             each directory or file to watch.



G:\Marsh\nodejs\mynpm-apps>nodemon src/index.js
[nodemon] 3.1.4
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,cjs,json
[nodemon] starting `node src/index.js`
server is ready

You just change any file content, see the output without restarting.























