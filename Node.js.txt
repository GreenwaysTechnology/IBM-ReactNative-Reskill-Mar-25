				Node.js
.....................................................................................

1.Core Node.js
2.npm fundamentals
3.Express.js
4.ORM integration/Database Programming


Core Node.js
.............

1.What is Node.js
2.Why Node.js
3.High level and low level architecture of Node.js
4.Node.js coding part

What is Node.js?
  Node.js js runtime env and platform to build js apps.


JS Runtime:

 where js apps/code to be executed.

places of js runtime

1.browser
   Every web browser has embedded js runtime.

 Every js runtime is different with respect to implementation but all js engine executes the code in similar way.
 every js engine implements the "ECMA" specification.

			ECMA Spec 
			   |
	-------------------------------------------------
	|              |                |        |
    Microsoft Edge  google chrome     Firefox   Opera
      Chakra           v8	   Spider Monkey

2.Standalone js engine
  Google only released first standalone js engine called v8 , also first open source js engine.
  based on v8 js engine only node.js was created.


What you can do with node.js? why node.js?
  
    Node was created to build non blocking io (network applications) applications

IO:
1.Blocking io
2.Non blocking io
3.IO and multi threading.

Why Node.js?
   NonBlocking IO:

in order to understand nonblocking io, we can take a look at how webserver works.

IO At low level:
..................

Every programming language offers api to talk to io channels, like reading data from disk,keyword,showing output in screen,sending data to network.

Without help of os , we cant perform any io operations.

		    language api
			|
		    os api  - system call
         		|
		    OS kernal -os low level layer
			|	 			
			|
		   os kernal program- file descriptor -c
			|
		 hard ware layer (hdd,Network card,monitor,keyboard)


Every file descriptor is just simple c program.
Every file descriptor program is made up of data structure called "array".

File descriptor is initalized when a process is created for eg, when you start notepad or powerpoint, when you start web server.

File descriptor is intialized with three entries.

Since fd is array , which is initalized with index base.

fd is always initalized with 3 entries

 index   Reference Pointer   Device
  0       STDIN              keyword
  1       STDOUT             Monitor
  2       STDERR             Monitor

Lets assume in the program we try to read file content or write file content into disk.

for eg in the code
    fs.read('path')

....................................................................................
			 Web server design and io
.....................................................................................

Web server is simple io program which reads and writes.

reads means request,writes means response.

web server receive request, webserver sends/writes response.


Every request is treated as io request.

How web server handles each each request?
   Every request is mapped against a single thread.
   Request per thread model

if 100 request, there would be 100 threads.

if 1000 request, we require 1000 threads
    
.....................................................................................
			Non blocking api

linux operating introduced first non blocking api
called select
in order to read data process used "receive/read" blocking api 
select + read 

select and read is initally good but not good in large scale so that new api was addeded is poll api.

Poll api was introduced to simplify the communication between kernal and process using event driven programming architecture.

Poll api had some limitation , so finally new api was introduced called "epoll"

...................................................................................
			C10 k problem, and Linux implemnetation
...................................................................................

Ngnix is the first non blocking webserver which was implemented in 2002 to 2003 in linux.

After success of linux operating system, other os Vendors started giving wrappers

Microsoft windows - iocp
Mac - Kqueue
unix and other bsd os - Kqueue.
linux - epoll

Now a days we use epoll, kqueue,iocp
.....................................................................................
			  Node.js and Nonblocking io
....................................................................................
Node.js was created based on nginx server in 2007.

The first programmable non blocking io arch is node.js.

Nodejs was created with two components

1.v8 
2.libuv
....................................................................................
			 libuv threading model
....................................................................................

node.js is multi threaded.

node.js libuv provides two types of threads

1.event loop thread - non blocking io threads
     This thread is responsible for handling non blocking io calls primerly networking io like web,sockets,udp...
  Per node process only one event loop thread is available

2.worker poll threads- blocking threads 
    This thread is responsible for handling blocking operations and some time non blocking file io operations
..............................................................................................

Programming:

1.Node module patterns
2.Types of modules
  2.1.core modules
3.npm fundamentals
4.Frameworks - Express.js


1.Node REPL
2.Node and js apis
3.Node core apis
4.Styles of writing async programming
   ->Callback pattern
   ->Promise Pattern
   ->Promise with Async and await Pattern


...................................................................................

1.Node REPL - Read Evaluate Print loop

Node REPL is used to run js programs interactive mode.

Js programs are executed in two modes

1.interactive mode - REPL mode
2.script mode - by loading script on to the runtime


....................................................................................
			node.js and js apis

node supports all js apis except browser specific apis

like window,document,sessionStorage etc...

> window
Uncaught ReferenceError: window is not defined
> document
Uncaught ReferenceError: document is not defined
>

in js , in browser "Window" super object.

in js, in node js, "Process" is super object

Process:
........
 It gives information about node.js platform.

.................................................................................
			 How to write non blocking apps
...................................................................................

Fundamental Requirement:
........................

1.OS should support non blocking apis like select, poll,epoll, iocp, kqueue

2.Program languages/platforms also should provide high level apis to map os low level apis

3.In order to write non blocking apps in js(node), we have different patterns(styles)

Nonblocking Applications Development style:
............................................

1.callbacks
2.Promises
3.Promise with Async await
4.reactive programming -rxjs


1.callbacks:
  Callback is listener function which gets registered during compile time
  and executed during runtime when ever the event is emitted.


Req for async programming:
 
1.You need high level non blocking api - provided by node.js 
2.listener api which is called "function as parameter/hof" 

HOF functions are becoming listeners/callbacks which are called when ever event is emitted.


NonBlocking apis:
1.timer
   -setTimeout
   -setInterval
2.io
   web
   fs
   socket
 etc...
3.process api
  nextTick
....................................................................................
			Higher order function
....................................................................................
function blockMe(message) {
    console.log(message)
}

function delay(callback) {
    callback()
}

function main() {
    blockMe('start')
    delay(function () {
        console.log('hello')
    })
    blockMe('end')
}
main()


...................................................................................
			How to implement non blocking using timers
...................................................................................
function blockMe(message) {
    console.log(message)
}

function delay(callback) {
    setTimeout(callback, 5000)
}

function main() {
    blockMe('start')
    delay(function () {
        console.log('hello')
    })
    blockMe('end')
}
main()
.....................................................................................
			How to pass data from non blocking api to listener
.....................................................................................
function blockMe(message) {
    console.log(message)
}

function delay(callback) {
    setTimeout(callback, 5000, 'hello')
}

function main() {
    blockMe('start')
    delay(function (message) {
        console.log(message)
    })
    blockMe('end')
}
main()
....................................................................................

callbacks with arrow:

const blockMe = (message) => console.log(message)

const sayHello = hello => setTimeout(hello, 5000, 'Hello!!')

blockMe('start')
sayHello(message => console.log(message))
blockMe('end')
.....................................................................................
			complex callbacks with biz logic:
.....................................................................................

How to handle success and failures?


const login = (userName, password, resolve, reject) => {
    if (userName === 'admin' && password === 'admin') {
        setTimeout(resolve, 100, 'Login success')
    } else {
        setTimeout(reject, 100, 'Login failed')
    }
}


function main() {
    login('admin', 'admin', (success) => {
        console.log(success)
    }, (err) => {
        console.log(err)
    })

    login('ddd', 'xxx', (success) => {
        console.log(success)
    }, (err) => {
        console.log(err)
    })
}
main()
.....................................................................................
  			Nested Callbacks
.................................................................................

The output of one callback will be input into another callback -  async composition.

//nested callback or async composition.
//the out put of one callback would be input to another callback.

//getUser ---> login ----> showDashboard

const getUser = (resolve, reject) => {
    console.log('getUser is called')
    let user = {
        name: 'admin'
    }
    //failure
    //user = null 
    if (user) {
        setTimeout(resolve, 100, user)
    } else {
        setTimeout(reject, 100, 'User Not found')
    }
}
const login = (user, resolve, reject) => {
    console.log('login is called')
    if (user.name === 'admin') {
        setTimeout(resolve, 100, 'login success')
    } else {
        setTimeout(reject, 100, 'login is failed')
    }

}
const showDashboard = (status, resolve, reject) => {
    console.log('showDashboard is called')
    if (status === 'login success') {
        setTimeout(resolve, 100, 'welcome to admin')
    } else {
        setTimeout(reject, 100, 'welcome to guest')
    }
}


function main() {
    getUser((user) => {
        login(user, (status) => {
            showDashboard(status, (page) => {
                console.log(page)
            }, (err) => {
                console.log(err)
            })
        }, (err) => {
            console.log(err)
        })
    }, (err) => {
        console.log(err)
    })
}
main()
....................................................................................
				Callback Hell
....................................................................................

function main() {
    getUser(user => {
        login(user, status => {
            showDashboard(status, (page) => {
                console.log(page)
            }, (err) => {
                console.log(err)
            })
        }, err => {
            console.log(err)
        })
    }, err => {
        console.log(err)
    })

}
main()

Questions:

1.Whether this code is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintainable?

No
fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})
Callback Hell:

 -It is not bug or error in code
 -It is way of writing callback based program
 -Callback based non blocking programming hard to understand, maintain, debug, scale Which   called as "Callback Hell".


How to write better async/non blocking code without callbacks?

-Generally without callbacks not possible to write async/non blocking code.
-Rather we can abstract complexity of writing callbacks.

....................................................................................
			  Promises
...................................................................................

In 2005, JQUERY team started with working complex callback patterns, they found callback hell problem.

They proposed a  Design pattern to write better callback programming(Async) programming.

  "Promise".

Promise is design pattern which hides complexity of callback patterns

Since Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks

In order standardize , ECMA committee decided to include Promise Design pattern at language level .(ES 6)
2012 E6 Committee introduced promise design pattern  as  "Promise" Object  in JavaScript.

.....................................................................................
		  Promise Design pattern Implementation in ES 6
.....................................................................................

Features of Promise Object:
1.Promise by default is Async. Which implements timer api with 0 ms .
2.Promise can be used with any async callback based  implementations.

Objective:

 To remove callbacks in async/non blocking code. write cleaner async programming.
 To remove complex callback chaining code.

Difference between callbacks and promises:

Essentially, a promise is a returned object to which you attach callbacks, instead of passing callbacks into a function.
....................................................................................

		Promise Implementation: Object  creations
...................................................................................

1. Create Promise Object from Promise constructor
      new Promise()
2. Create Promise object from factory apis 
      Promise.resolve() / Promise.reject()

Promise object methods:

1.then - success
2.catch - errors
3.finally - clean up

factory api to create Promise object
4.resolve
5.reject
.......................................
6.all
7.race

1.Promise factory api
   -success - resolve
   -failure - reject

//basic promise implementation:
//In promises , you don't need to pass function as parameter

Promise with Success and also ensure that Promise is async.

//basic promise implementation:
//In promises , you dont need to pass function as parameter

Promise with Success and also ensure that Promise is async.


function blockMe(message) {
    console.log(message)
}

function getValue() {
    return Promise.resolve(10)
}


function main() {
    blockMe('start')
    getValue().then(value => {
        console.log(value)
    })
    blockMe('end')
}
main()
///

Promise With error:

function blockMe(message) {
    console.log(message)
}

function getError() {
    return Promise.reject('something went wrong')
}


function main() {
    blockMe('start')
    getError().catch(err => {
        console.log(err)
    })
    blockMe('end')
}
main()

Promise with success and failure: with biz logic.



function login(userName, password) {
    if (userName === 'admin' && password === 'admin') {
        return Promise.resolve('login success')
    } else {
        return Promise.reject('login is failed')
    }
}


function main() {
    login('admin', 'admin')
        .then(status => {
            console.log(status)
        }).catch(err => {
            console.log(err)
        })
    login('xxx', 'yy')
        .then(status => {
            console.log(status)
        }).catch(err => {
            console.log(err)
        })
}
main()


2.Promise Constructor Api
.........................

i want to return users after 1000ms
if i want to wrap any existing callback based program into promise based 

              "You have to use Promise Constructor Pattern"


Promise with value:

function getValue() {
    return new Promise((resolve, reject) => {
        setTimeout(resolve, 1000, 10)
    })
}



function main() {
    getValue().then(value => console.log(value))
}
main()

Promise with biz logic:
.....................

function login(userName, password) {
    return new Promise((resolve, reject) => {
        if (userName === 'admin' && password === 'admin') {
            setTimeout(resolve, 1000, 'login success')
        } else {
            setTimeout(reject, 1000, 'login failed')
        }
    })
}



function main() {
    login('admin','admin')
        .then(status => console.log(status))
        .catch(err => {
            console.log(err)
        })
}
main()
....................................................................................
			Callback hell and promises
.....................................................................................

const getUser = () => {
    console.log('getUser is called')
    return new Promise((resolve, reject) => {
        let user = {
            name: 'admin'
        }
        //failure
        //user = null 
        if (user) {
            setTimeout(resolve, 100, user)
        } else {
            setTimeout(reject, 100, 'User Not found')
        }
    })
}
const login = user => {
    console.log('login is called')
    return new Promise((resolve, reject) => {
        if (user.name === 'admin') {
            setTimeout(resolve, 100, 'login success')
        } else {
            setTimeout(reject, 100, 'login is failed')
        }
    })

}
const showDashboard = status => {
    console.log('showDashboard is called')
    return new Promise((resolve, reject) => {
        if (status === 'login success') {
            setTimeout(resolve, 100, 'welcome to admin')
        } else {
            setTimeout(reject, 100, 'welcome to guest')
        }
    })
}


function main() {
    // getUser((user) => {
    //     login(user, (status) => {
    //         showDashboard(status, (page) => {
    //             console.log(page)
    //         }, (err) => {
    //             console.log(err)
    //         })
    //     }, (err) => {
    //         console.log(err)
    //     })
    // }, (err) => {
    //     console.log(err)
    // })


    //with promise chaining
    // getUser()
    //     .then(user => {
    //         login(user).then(status => {
    //             showDashboard(status).then(page => {
    //                 console.log(page)
    //             }).catch(err => console.log(err))
    //         }).catch(err => {
    //             console.log(err)
    //         })
    //     })
    //     .catch(err => console.log(err))

    // getUser()
    //     .then(user => {
    //         return login(user)
    //     })
    //     .then(status => {
    //         return showDashboard(status)
    //     })
    //     .then(page => {
    //         console.log(page)
    //     })
    //     .catch(err => console.log(err))

    // getUser()
    //     .then(user => login(user))
    //     .then(status => showDashboard(status))
    //     .then(page => console.log(page))
    //     .catch(err => console.log(err))

    const { log } = console
    getUser()
        .then(login)
        .then(showDashboard)
        .then(log)
        .catch(log)

}
main()
.....................................................................................
				Promise Hell
.....................................................................................

const getUser = () => {
    console.log('getUser is called')
    return new Promise((resolve, reject) => {
        let user = {
            name: 'admin'
        }
        //  user = null
        if (user) {
            setTimeout(resolve, 1000, user)
        } else {
            setTimeout(reject, 1000, { message: 'User not found' })
        }
    })
}
const login = (user) => {
    console.log('login is called')
    return new Promise((resolve, reject) => {
        if (user.name === 'admin') {
            setTimeout(resolve, 1000, 'login success')
        } else {
            setTimeout(reject, 1000, 'login failed')
        }
    })
}
const showDashboard = (status) => {
    console.log('showDashboard is called')
    return new Promise((resolve, reject) => {
        if (status === 'login success') {
            setTimeout(resolve, 1000, 'Welcome to dashboard')
        } else {
            setTimeout(reject, 1000, 'Sorry Try again')
        }
    })
}


function main() {
      getUser()
        .then(user => login(user))
        .then(status => showDashboard(status))
        .then(page => console.log(page))
        .catch(err => console.log(err))

}
main()
Here we have so many "thens" or "thenables".

In order reduce thenables, ES 7 Introduced new key words to abstract promise then and catch are "async and await"

async keyword:

1.in front of function we use async keyword, meaning that the function returns promise by default with success only.



// function getValue() {
//     return 10
// }

// function getValue() {
//     return Promise.resolve(10)
// }

async function getValue() {
    return 10  // Promise.resolve(10)
}

function main() {
    const value = getValue()
    console.log(value)
    value.then(res => console.log(res))
}
main()

await:
   to resolve promise without using then and catch methods.
   await makes promise code like normal sync code
 

async function login(userName, password) {
    if (userName === 'admin' && password === 'admin') {
        return 'login success'
    } else {
        return Promise.reject('login is failed')
    }
}

async function main() {
    try {
        const status = await login('admin','admin')
        console.log(status)
    }
    catch (err) {
        console.log(err)
    }
}
main()
.................

Promise chaining with async and await keyword
const getUser = () => {
    console.log('getUser is called')
    return new Promise((resolve, reject) => {
        let user = {
            name: 'admin'
        }
        //failure
        //user = null 
        if (user) {
            setTimeout(resolve, 100, user)
        } else {
            setTimeout(reject, 100, 'User Not found')
        }
    })
}
const login = user => {
    console.log('login is called')
    return new Promise((resolve, reject) => {
        if (user.name === 'admin') {
            setTimeout(resolve, 100, 'login success')
        } else {
            setTimeout(reject, 100, 'login is failed')
        }
    })

}
const showDashboard = status => {
    console.log('showDashboard is called')
    return new Promise((resolve, reject) => {
        if (status === 'login success') {
            setTimeout(resolve, 100, 'welcome to admin')
        } else {
            setTimeout(reject, 100, 'welcome to guest')
        }
    })
}


async function main() {
    try {
        const user = await getUser()
        const status = await login(user)
        const page = await showDashboard(status)
        console.log(user,status,page)  
    }
    catch (err) {
        console.log(err)
    }
}
main()
.....................................................................................
			Types of modules
.....................................................................................

1.Custom module
   built by us
2.built in modules
   provided by node.js  
3.provided by third party/community
  libs,frameworks

.......................................................................................
				Modules Pattern
			       (Custom Module)
...................................................................................

CommonJs:
 It is one the module pattern , introduced in 2006, node adopted commonjs as default module pattern.
 node provides commonjs implementation by default.

You can write node apps using es6 module pattern as well.

How to share code? How to import code?

 Code:
  Could be variables, functions, classes.
  Variables can have any literal string,numbers,boolean,objects,functions...

How to share code? How to import code?

 Code:
  Could be variables,functions,classes.
  Variables can have any literal string,numbers,boolean,objects,functions...

src
  |
  subfolders
|
index.js

Sharing code :

Keywords
exports
module.exports

Importing code:

require('fileName')
require('folderName/fileName')

exports:
 Used to share more code from the single file.
 exports packs the entire code into one single js object and returns that object

//pack the code 
exports.firstName = 'Subramanian'
exports.lastName = 'Murugan'
exports.salary = 1000
exports.status = true
exports.address = {
    city: 'Coimbatore'
}
exports.skills = ['Java','JavaScript','Node.js']


require:
  It is a function which returns what ever we exported from the file.

const obj= require('fileName')



src/util.myutil.js

//pack the code 
exports.firstName = 'Subramanian'
exports.lastName = 'Murugan'
exports.salary = 1000
exports.status = true
exports.address = {
    city: 'Coimbatore'
}
exports.skills = ['Java', 'JavaScript', 'Node.js']
exports.saySomething = () => "something"

src/index.js
//access the code from the myutil.js 
const res = require('./util/myutil')
console.log(res)

console.log(`${res.firstName} ${res.lastName} ${res.address.city} ${res.salary}`)
console.log(`${res.skills} ${res.status} ${res.saySomething()}`)

node src/index.js
{
  firstName: 'Subramanian',
  lastName: 'Murugan',
  salary: 1000,
  status: true,
  address: { city: 'Coimbatore' },
  skills: [ 'Java', 'JavaScript', 'Node.js' ],
  saySomething: [Function (anonymous)]
}
Subramanian Murugan Coimbatore 1000
Java,JavaScript,Node.js true something
....................................................................................
				module.exports
....................................................................................

Export only one item from the file.

eg"
 if you want to share  "Class"
 if you want to share "array"
 if you want to share "object"



src/services/todo.service.js

class TodoService {
    constructor() {

    }
    //biz apis
    save() {
        return 'save'
    }
    findAll() {
        return 'findAll'
    }
    find() {
        return 'find'
    }
    remove() {
        return 'remove'
    }
}
// module.exports = TodoService

//return object 
module.exports = new TodoService()


src/index.js
// const TodoService = require('./services/todo.service')
const todoService = require('./services/todo.service')

// let service = new TodoService()

// console.log(service.save())
// console.log(service.findAll())

console.log(todoService.save())
console.log(todoService.findAll())

.................................................................................
				 Returning data
.................................................................................

src/mockdata/todo.mock.js


const TODOS = require('../mockdata/todo')
class TodoService {
    constructor() {

    }
    //biz apis
    save() {
        return 'save'
    }
    findAll() {
        return TODOS
    }
    find() {
        return 'find'
    }
    remove() {
        return 'remove'
    }
}
// module.exports = TodoService

//return object 
module.exports = new TodoService()

src/index.js
// const TodoService = require('./services/todo.service')
const todoService = require('./services/todo.service')

// let service = new TodoService()

// console.log(service.save())
// console.log(service.findAll())

console.log(todoService.save())
console.log(todoService.findAll())

How to use es6 module inside node?

Before node 16, there was no direct support of es6 modules, now we can run es6 modules code inside node with some configuration.

src/lib/mylib.js
export const firstName = 'Subramanian'
export const lastName = 'Murugan'

src/index.js
import { firstName,lastName } from "./lib/mylib.js";

console.log(firstName,lastName)

>node src/index.js
Subramanian Murugan

Mixing commonjs and es 6 module:
src/lib/todo.service.js
class TodoService {
    findAll() {
        return ["done"]
    }
}
module.exports = new TodoService()

src/index.js
import { firstName, lastName } from "./lib/mylib.js";
import pkg from './lib/todo.service.js';
const { findAll } = pkg;

console.log(firstName, lastName)
console.log(findAll())
.............................................................................................
Built in Node.js Modules:
.........................
https://nodejs.org/docs/latest/api/

Built in node modules provides

1.non blocking networking io apis
   -tcp,http,datagram etc...
2.timers
3.file system api
   to read and write data into disk files
4.common apis
   os,events


Common apis:

1.OS
const os = require('node:os')

function main(){
    console.log(os.arch())
    console.log(os.cpus())
}
main()

2.Events:
import { EventEmitter } from 'node:events'

//custom event driven programming
//to register listener we have "on" method, to emit event we have "emit method"

class Sales extends EventEmitter {
    constructor() {
        super()
        this.on('onsold', (evt) => {
            console.log(evt)
        })
    }
    sale(product) {
        this.emit('onsold', product)
    }
}
function main() {
    let sales = new Sales()
    sales.sale({ id: 1, name: 'product1' })
}
main()
............................................................................................
				Web Applications in Node
...........................................................................................

.....................................................................................
			HTTP programming
....................................................................................
Node was created to build non blocking web server and web applications.
Node provides single event loop thread which handles lot of concurrent http requests.
Node offers high level http wrapper apis to talk to os apis.
Node offers http as object.

HTTP Objects

1.Agent -  http.Agent
  For handling connections between and server

2.ClientRequest - http.clientRequest
  For creating http clients

3.Server - http.Server
  For creating web servers,we can create app and deploy on top of server.
  
4.ServerResponse - http.ServerResponse
  ServerResponse is outputstream of "http socket"

5.IncomingMessage -http.IncomingMessage
    The payload which is sent by client -  Message

6.OutgoingMessage -http.OutgoingMessage
    The data which is sent by server - Message

7.Global Methods of http
  
 1.createServer
    factory method to create http server instance.
HTTP events:
 
 There are three types of events

1.HTTP Request events
  Which are triggered whenever client request is recived by server

request.on('nameoftheevent',listner)

2.Http Response events
   Which are triggered whenever server response is sent by server

response.on('nameoftheevent',listner)

3.Server Events
   Server events are triggered during server startup,connection,handshake,request

 server.on('nameoftheevent',listner)

common events:
data,close,end,error

Note:
 Each Object has its own events apart from common events.

/////////////////////////////////////////////////////////////////////////////////////


First Web Server: Helloworld
//simple web server
const http = require('node:http')

//create Http Server
const server = http.createServer((request, response) => {
    //write code to handle request and response
    response.write('Hello')
    //close the stream
    response.end()
})


//start the server
server.listen(3000, () => {
    console.log('server is ready')
})

How to attach Events?
request,response,server.

//simple web server
const http = require('node:http')

//create Http Server
const server = http.createServer((request, response) => {
    //write code to handle request and response
    response.write('Hello')
    //close the stream
    response.end()
})


//start the server
server.listen(3000, () => {
    console.log('server is ready')
})

//attach server listener
server.on('request', (request, response) => {
    console.log(`Request received on ${new Date()} URL ${request.url} method ${request.method}`)
})
...................................................................................
			  How to send json payload 
.....................................................................................

const http = require('node:http')

const server = http.createServer((request, response) => {
    const data = [{ id: 1, name: 'Subramanian' }, { id: 2, name: 'Ram' }]
    const jsonData = JSON.stringify(data)
    //set content type
    response.writeHead(200, {
        'Content-Type': 'application/json'
    })
    response.write(jsonData)
    response.end()
})

//start the server
server.listen(3000, () => {
    console.log('server is ready')
})
.....................................................................................
			Module driven web app with sync and async
.....................................................................................

src/services/user.service.js
const USERS = require('../mock-data/users')

class UserService {
    constructor() {

    }
    //sync api
    findAll() {
        return USERS;
    }
    //async api -  using Promises
    findAllAsync() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, USERS)
        })
    }
}
module.exports = new UserService()

src/index.js
const http = require('node:http')
const { findAll } = require('./services/user.service')

// const server = http.createServer((request, response) => {
//     const data = findAll()
//     const jsonData = JSON.stringify(data)
//     //set content type
//     response.writeHead(200, {
//         'Content-Type': 'application/json'
//     })
//     response.write(jsonData)
//     response.end()
// })
const server = http.createServer(async (request, response) => {
    try {
        response.writeHead(200, {
            'Content-Type': 'application/json'
        })
        const data = await findAll()
        const jsonData = JSON.stringify(data)
        response.end(jsonData)
    }
    catch (err) {
        response.writeHead(500, {
            'Content-Type': 'application/json'
        })
        response.end({ err: err })
    }
})
//start the server
server.listen(3000, () => {
    console.log('server is ready')
})
....................................................................................
			How to pass data to server
....................................................................................
src/services/user.service.js
const USERS = require('../mock-data/users')

class UserService {
    constructor() {

    }
    //sync api
    findAll() {
        return USERS;
    }
    //async api -  using Promises
    findAllAsync() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, USERS)
        })
    }
    save(user) {
        console.log(user)
    }
}
module.exports = new UserService()

src/index.js
const http = require('node:http')
const { save } = require('./services/user.service')

const server = http.createServer((request, response) => {
    //get input
    let data = ''
    request.on('data', (chunk) => {
        data += chunk
    })
    request.on('end', () => {
        //call save method
        save(JSON.parse(data))
        response.end('save')
    })
})
//start the server
server.listen(3000, () => {
    console.log('server is ready')
})

...................................................................................
				NPM
.....................................................................................
What is npm?
 npm is the world's largest software registry.
 open source developers from every part of the world use npm to share and borrow packages.
 many organizations use npm to manage private development as well.

In js, you might have created lib/framework/utility, if you want to share to other developers in the world or within your organization or your team - npm helps.


NPM consists of three components

1.the website - used to discover packages, setup profiles and manage other aspects of npm -https://www.npmjs.com/

2.CLI runs from the terminal, and how most developers interact with npm.
  npm is cli name/command , which is distributed alone node.js itself

3.registry - it is  large public database of js software and the meta information surrounding it.

core concepts in npm:

1.package
2.module

What is package?
   A package is a "file or directory" that is described by a "package.json" file

   A package must contain package.json file in order to be published to the npm    registry


Modules:
  A module is any "file or directory" in the "node_modules" directory that can be loaded by the node.js require function.

 A JavaScript file
...................................................................................
				NPM
.....................................................................................

What is npm?
 npm is the world's largest software registry.
 open source developers from every part of the world use npm to share and borrow packages.
 many organizations use npm to manage private development as well.

In js, you might have created lib/framework/utility, if you want to share to other developers in the world or within your organization or your team - npm helps.


NPM consists of three components

1.the website - used to discover packages, setup profiles and manage other aspects of npm -https://www.npmjs.com/

2.CLI runs from the terminal, and how most developers interact with npm.
  npm is cli name/command , which is distributed alone node.js itself

3.registry - it is  large public database of js software and the meta information surrounding it.

core concepts in npm:

1.package
2.module

What is package?
   A package is a "file or directory" that is described by a "package.json" file

   A package must contain package.json file in order to be published to the npm    registry


Modules:
  A module is any "file or directory" in the "node_modules" directory that can be loaded by the node.js require function.

 A JavaScript file
....
....................................................................................
				How to create npm package
....................................................................................

package.json

=>It is file which describes about your project/app/file/directory.

i have created a project like

myapp/src/util/lib.js

class A{}

module.exports = new A()

myapp/src/util/index.js
const A= require('./util/lib.js')

Can you call this project as "package"

No
Because this project does not contain "package.json",Which are called module
...................................................................................

i have created a project like

myapp/src/util/lib.js

class A{}

module.exports = new A()

myapp/src/util/index.js
const A= require('./util/lib.js')

myapp/package.json


Can you call this project as "package"

Yes

Why package.json?

=>if package.json is there, only we can transfer/share to other developers via "npm registry"

Note:
 Every js project must have package.json file

Steps:

1.create folder
>mkdir mynpm-apps
>cd mynpm-apps
>mkdir src

2.create package.json

Before create you have to ensure that npm has been installed.

npm init <initalizer>

npm init
This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.

See `npm help init` for definitive documentation on these fields
and exactly what they do.

package.json

{
  "name": "mynpmapps",
  "version": "1.0.0",
  "description": "This is demo package",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "my",
    "demo",
    "package"
  ],
  "author": "Subramanian Murugan",
  "license": "ISC"
}
name:
 This is used to publish package into registry

version:
   if you publish package into registry, which is differentiated by "version"

"1.0.0" - version no is based on the concept called "SEM Ver" concept- Semantic versioning.
 Major.minor.patch

main:
  It is main file used /entry file in the package , generally it would index.js or main.js

description:
  It explains the nature of packages- what is this packge.

Keywords:
  Used to discover your packages using npm search command

author:
  Who is author of this package

license:
  You should specify a license for your package so that people know how they are permitted to use it.
....................................................................................
				Node Packages

How to install node packages which was distributed by others?

npm install [<package-name>]
npm i [<package-name>]

npm i [<package-name>] --options


Options:

 --save
     for production + dev
 --save-dev
     -for only for dev 
 --production
    -for only production
  -g
    -for tool purpose -dev

No options are given by default "--save"

if you want to use any lib

Steps;
1.ensure that package.json is created or not - one time
2.npm i packageName --options
3.after installing you can verify , the node_modules folder is created and installed
  libs inside that folder.
  You have to verify package.json as well, there is one entry is added

  "dependencies": {
    "lodash": "^4.17.21"
  }


3.How to use package inside our code?
  Using cjs or es6 module.

//i want to use lodash lib
const _ = require('lodash')

//start using lib

function main() {
    const res = _.partition([1, 2, 3, 4], n => n % 2);
    console.log(res)
}
main()

Application mode

1.dev
2.test
3.prod

dev : any dependency required for development only
  --save-dev
test : 
   any dependency required for development only - test
   --save-dev
prod:
  dependency used in dev and production... 
  --save
"dependencies": {
    "lodash": "^4.17.21"
  }

..................................................................................
			 Test /Dev Only Dependency
.................................................................................

Libs required for dev and test

tools
   -compilers, webservers
   -testing libs and frameworks 

eg:
  mocha - test runner is used for running test case
  chai.js -test assertion lib used for writing test cases
  jest -  test runner is used for running test cases

how to install chai?

G:\Marsh\nodejs\mynpm-apps>npm i chai --save-dev

added 7 packages, and audited 9 packages in 2s

found 0 vulnerabilities

 "devDependencies": {
    "chai": "^5.1.1",
    "mocha": "^10.7.3"
  }
.....................................................................................
.....................................................................................
			How to prepare your app for production
.....................................................................................

When you upload the app into source code repository like "github/bitbucket" , we never upload node_modules folder.

Steps for Testing:

1.just delete node_modules folder

2.open command prompt

3.create production app

npm install --production
  it scans package.json which install only from  production dependencies
or
npm install --omit=dev
  it scans package.json which install only from  production dependencies			
....................................................................................
		How to install all dependencies 
....................................................................................
mynpm-apps>npm i
.....................................................................................
,,,,,,,,,,,,,........................................................................
			  Global Packages
....................................................................................
Global package is installed not inside project, installed globally.
Global packages are generally tools to create projects ,webservers, test runtime like so.

nodemon:
  nodemon is a tool that helps develop Node.js based applications by automatically restarting the node application when file changes in the directory are detected.
 
npm install nodemon -g

global modules are available like executable files

How to test?

mynpm-apps>nodemon --help
  Usage: nodemon [options] [script.js] [args]

  Options:

  --config file ............ alternate nodemon.json config file to use
  -e, --ext ................ extensions to look for, ie. js,pug,hbs.
  -x, --exec app ........... execute script with "app", ie. -x "python -v".
  -w, --watch path ......... watch directory "path" or files. use once for
                             each directory or file to watch.



G:\Marsh\nodejs\mynpm-apps>nodemon src/index.js
[nodemon] 3.1.4
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,cjs,json
[nodemon] starting `node src/index.js`
server is ready

You just change any file content, see the output without restarting.

Tools we have installed globally like nodemon.

In order to avoid version mismatch, we can install any tools(webservers,compilers,utilites) as local module.

G:\Marsh\nodejs\mynpm-apps>npm uninstall nodemon -g

removed 29 packages in 1s

G:\Marsh\nodejs\mynpm-apps>nodemon
'nodemon' is not recognized as an internal or external command,
operable program or batch file.


npm install nodemon -save-dev
After installing,nodemon is not available to execute like 

nodemon src/index.js
Error:
nodemon' is not recognized as an internal or external command,
operable program or batch file.

Solution:
 We have to configure inside scripts section using builtin commoand or custom command

"scripts": {
      "dev": "nodemon src/index.js"
  }

npm run dev
.....................................................................................
.....................................................................................
			How to use tools without even installing locally
.....................................................................................
Can i use tools like webserver,compiler,code generator without even installing inside project as dev?

npx command

Either local or global module we need to install, it occupies some amount memory.
if you want to execute tools with latest version always,you have to upgrade, instead of upgrading , we can directly execute the latest version of binary.

npx

.....................................................................................

Alternate to npm

1.npx
2.yarn
3.npmn
....................................................................................
			  Express.js - Web /Api Framework For node.js
.....................................................................................


What is express?
Express Fast, unopinionated, minimalist web framework for Node.js
express is built on top of http core module.


What apps can be built using express?


1.RESTFull WebServices

2.Dynamic content generation apps -  spring mvc, .netmvc.   with ui


Core features of Express:

1.Abstraction on core http module
2.lot of apis to send data like json api
3.routers : to create HTTP based web services and apps quickly.
4.middlewares : to extend core framework like - logging,database,security,templates...

Types of distributed Apps:

1.Monolithic App
2.Microservices

Express can be used to build Microservices?

 No,
Express is just monolithic App framework
.....................................................................................
		Express Key concepts: in express every thing object

Objects in express

1.Application
  We call Container object which contain other objects
  entry and exit of an application
  application is created by calling function

2.Request

3.Response

4.Router


1.Application object roll:

-Routing HTTP requests
-Configuring middleware
-Rendering HTML views
-Registering a template engine


.....................................................................................
				Express- Coding
.....................................................................................

Express : HelloWorld

File Name : app.js - conventional name but you can save index.js as well.

//import express function
const express = require('express')
// console.log(express)

//creating application object
const app = express()

// console.log(app)

//api:
app.get('/hello', (req, res) => {
    //send response
    res.end('Hello Express')
})


//start the server

app.listen(3000, () => {
    console.log('Express Server is Ready!')
})
.................................................................................
.................................................................................
			HTTP verbs and CURD
....................................................................................

HTTP Verbs         Operation Type

GET                Read

POST               Write

PUT                Update

DELETE             Remove

URL Pattern:
///////////
Every Http Verbs are mapped against url

/api/customers        -GET ,POST,PUT,DELETE
/api/products
/api/reviews
 
CURD:
const express = require('express')
const app = express()

app.get('/api/customers', (req, res) => {
    res.end('customers -get')
})
app.post('/api/customers', (req, res) => {
    res.end('customers -post')
})
app.put('/api/customers', (req, res) => {
    res.end('customers -put')
})
app.delete('/api/customers', (req, res) => {
    res.end('customers -delete')
})
app.listen(3000, () => {
    console.log('Express Server is Ready!')
})
...................................................................................
			PORT,getting Server Info
...................................................................................

const express = require('express')
const app = express()

const PORT = 3000

app.get('/api/customers', (req, res) => {
    res.end('customers -get')
})
app.post('/api/customers', (req, res) => {
    res.end('customers -post')
})
app.put('/api/customers', (req, res) => {
    res.end('customers -put')
})
app.delete('/api/customers', (req, res) => {
    res.end('customers -delete')
})
const server = app.listen(PORT, () => {
    console.log(`Express server is running at ${server.address().port}`)
})
.....................................................................................
.....................................................................................
			Modularity,Async,JSON Payload
....................................................................................

src/services/customer.service.js

const CUSTOMERS = [{
    id: 1,
    name: 'Subramanian',
    location: 'Coimbatore'
}]

class CustomerService {

    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, CUSTOMERS)
        })
    }
}
module.exports = new CustomerService()

src/app.js
const express = require('express')
const app = express()
const customerServicce = require('./services/customer.service')

const PORT = 3000

app.get('/api/customers', async (req, res) => {
    try {
        const customers = await customerServicce.findAll()
        res.status(200).json(customers)
    }
    catch (err) {
        res.status(500).json(err)
    }
})
const server = app.listen(PORT, () => {
    console.log(`Express server is running at ${server.address().port}`)
})

...................................................................................
			Externalized configuration
...................................................................................

We are going to use ".env" file.


We are going to use ".env" file.

Step : 1 Create file under root project dir
project
 |
 .env

Step 2: install dotenv dependency

npm install dotenv --save

Step 3: grab env variables

const express = require('express')
const { findAll } = require('./services/user.service')
require('dotenv').config()

const app = express()

//console.log(process.env.PORT)

const PORT = process.env.PORT || 3000

app.get('/', (req, res) => {
    res.end('Home Page')
})
app.get('/api/users', async (req, res) => {
    try {
        const users = await findAll();
        res.json(users)
    }
    catch (err) {
        res.json({ err: err })
    }
})

//start server
const server = app.listen(PORT, () => {
    console.log(server.address())
    console.log(`Express is running @ ${server.address().port}`)
})

Task
.....
Multi Enviroment configuration: explore how to configure for different environments
like production,dev,staging,testing
https://www.npmjs.com/package/dotenv
.....
...................................................................................
....................................................................................
			Resources
....................................................................................

YourApp
  |
  routers - controllers
    |
    products
    customers
    payments
 |
  services
    products
    customers
    payments
 |
  repository
    products
    customers
 |
  
 app.js
..................................................................................... 
....................................................................................
			Resources
....................................................................................

YourApp
  |
  routers - controllers
    |
    products
    customers
    payments
 |
  services
    products
    customers
    payments
 |
  repository
    products
    customers
 |
  
 app.js
..................................................................................... Router:
  It is object used to isloate apis into separate folders and files


eg:

src/services/customer.service.js

const CUSTOMERS = [{
    id: 1,
    name: 'Subramanian',
    location: 'Coimbatore'
}]

class CustomerService {

    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, CUSTOMERS)
        })
    }
    async save() {
        return "save"
    }
}
module.exports = new CustomerService()

src/services/product.service.js

const PRODUCTS = [{
    id: 1,
    name: 'phone'
}]

class ProductService {

    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, PRODUCTS)
        })
    }
    async save() {
        return "save"
    }
}
module.exports = new ProductService()
...............

Router:

src/routers/product.router.js
const express = require('express')
const productService = require('../services/product.service')
//create Router Object
const productRouter = express.Router()

productRouter.get('/', async (req, res) => {
    try {
        const products = await productService.findAll();
        res.json(products)
    }
    catch (err) {
        res.json({ err: err })
    }
})

productRouter.post('/', async (req, res) => {
    try {
        const product = await productService.save();
        res.json({ product })
    }
    catch (err) {
        res.json({ err: err })
    }
})


module.exports = productRouter

src/routers/customer.router.js
const express = require('express')
const customerServicce = require('../services/customer.service')
//create Router Object
const customerRouter = express.Router()

//apis - get,getById,save,delete,update
//api/customers/
customerRouter.get('/', async (req, res) => {
    try {
        const users = await customerServicce.findAll();
        res.json(users)
    }
    catch (err) {
        res.json({ err: err })
    }
})

customerRouter.post('/', async (req, res) => {
    try {
        const user = await customerServicce.save();
        res.json(user)
    }
    catch (err) {
        res.json({ err: err })
    }
})


module.exports = customerRouter

src/app.js
const express = require('express')
// const customerRouter = require('./routers/customer.router')
require('dotenv').config()
const app = express()

//Configure the router with application object
// app.use('/api/customers', customerRouter)
app.use('/api/customers', require('./routers/customer.router'))
app.use('/api/products', require('./routers/products.router'))

const PORT = process.env.PORT || 3000


const server = app.listen(PORT, () => {
    console.log(`Express server is running at ${server.address().port}`)
})
.............................................................................................
....................................................................................
			  Dynamic Parameters : PATH PARAM
.....................................................................................

eg:

 GET /api/customers/1 
 GET /api/customers/2 

How to read parameter

router | app.get('/:id',(req,res)=>{
  const id = req.params.id
})

eg:


const CUSTOMERS = [{
    id: 1,
    name: 'Subramanian',
    location: 'Coimbatore'
}]

class CustomerService {

    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, CUSTOMERS)
        })
    }
    findById(id) {
        return CUSTOMERS.find(customer => customer.id === id)
    }
    async save() {
        return "save"
    }
}
module.exports = new CustomerService()


Router:
const express = require('express')
const customerServicce = require('../services/customer.service')
//create Router Object
const customerRouter = express.Router()

//apis - get,getById,save,delete,update
//api/customers/
customerRouter.get('/', async (req, res) => {
    try {
        const users = await customerServicce.findAll();
        res.json(users)
    }
    catch (err) {
        res.json({ err: err })
    }
})

customerRouter.get('/:id', async (req, res) => {
    try {
        const id = parseInt(req.params.id)
        const customer = await customerServicce.findById(id);
        if (customer) {
            return res.json(customer)
        }
        return res.status(500).json({ err: `Requestd Customer ${id} Not Found` })

    }
    catch (err) {
        res.json({ err: err })
    }
})

customerRouter.post('/', async (req, res) => {
    try {
        const user = await customerServicce.save();
        res.json(user)
    }
    catch (err) {
        res.json({ err: err })
    }
})


module.exports = customerRouter

Testing:
GET localhost:3000/api/customers/1

{
    "id": 1,
    "name": "Subramanian",
    "location": "Coimbatore"
}

GET localhost:3000/api/customers/2

{
    "err": "Requestd Customer 2 Not Found"
}

....................................................................................
			Dynamic Parameters : Query Parameters

URL Pattern:
localhost:3000/api/customers/filter?city=chennai&state=TN

customerRouter.get('/filter', async (req, res) => {
    try {
        const params = req.query
        console.log(params)
        return res.status(200).json({ message: params })
    }
    catch (err) {
        return res.status(500).json({ err })
    }
})


output:
Express Web Server is running at 3000
{ city: 'chennai' }
{ city: 'chennai', state: 'TN' }

or 
customerRouter.get('/filter', async (req, res) => {
    try {
        // const params = req.query
        // console.log(params)
        // return res.status(200).json({ message: params })
        const { city, state } = req.query
        return res.status(200).json({ city, state })
    }
    catch (err) {
        return res.status(500).json({ err })
    }
})
...........................................................................................
			Middlewares and database integration
...........................................................................................
Middlewares:

 What is Middleware?
 
 Middleware is JavaScript function that have access request object and response and next function in the application request response cycle.

...................................................................................
			  Express middlewares
...................................................................................

Middlewares:

 What is Middleware?
 
 Middleware is javascript function that have access request object and response and next function in the application request response cycle.
  
 The difference between normal function which handles req and response with express , express takes third arg

 normal function
  app.get('url',(req,res)=>{})

 Middleware function
  app.get('url',(req,res,next)=>{
       //pre and post processing
  })
 req and res are objects
 next is a function

The "next" function is a function in the express router which, when invoked, executes the middleware succeeding the current middleware.

Tasks are middleware is doing:

1.Execute any code
2.Make changes to request and response object before handling real req and res cycle.
3.Middlwares can be attached on application object and also router object


use Method
  use method is used to registry middleware.

app.use
router.use

app.use('/api/users', require('./routers/users/user.router'))

 In this code we have registered already middleware which is called as "routerMidleware" - Router itself is middleware.

How to write our own middleware? - Custom Middleware.

Use Case : Middleware for GET /hello

const express = require('express')
require('dotenv').config()

const app = express()
const PORT = process.env.PORT || 3000

//middleware 
//req is object
//res is object
//next is function
app.get('/hello', (req, res, next) => {
    //middleware logic
    console.log('middleware is called')
    //move to next middleware in the chain or to request handler
    next()
})
app.get('/hello', (req, res) => {
    return res.end('hello')
})


const server = app.listen(PORT, () => {
    console.log(`Express server is running at ${server.address().port}`)
})
				
Sending custom headers
........................
const express = require('express')
const app = express()
require('dotenv').config()

const PORT = process.env.PORT || 3000

//middleware
app.get('/hello', (req, res, next) => {
    //middleware code
    console.log('middleware is called')
    res.set({ 'secret': '222232ssfsfsdf' })
    next() //this is required
})

//route
app.get('/hello', (req, res) => {
    res.end('hello')
})
//start server
const server = app.listen(PORT, () => {
    console.log(`Express Web Server is running at ${server.address().port}`)
})

The above middleware is called only for '/hello' router.
.....................................................................................
			 Global Middleware
.....................................................................................
I want to execute middleware for all route and all http methods in application.

const express = require('express')
const app = express()
require('dotenv').config()

const PORT = process.env.PORT || 3000

//middleware
app.use((req, res, next) => {
    //middleware code
    console.log('middleware is called')
    res.set({ 'secret': '222232ssfsfsdf' })
    next() //this is required
})

//route
app.get('/hello', (req, res) => {
    res.end('hello')
})

app.get('/hai', (req, res) => {
    res.end('hai')
})
//start server
const server = app.listen(PORT, () => {
    console.log(`Express Web Server is running at ${server.address().port}`)
})

....................................................................................
		Specific Url , any http method
....................................................................................

const express = require('express')
const app = express()
require('dotenv').config()

const PORT = process.env.PORT || 3000

//middleware
app.post('/hello',(req, res, next) => {
    res.set({ 'secret': '222232ssfsfsdf' })
    next() //this is required
})

//route
app.get('/hello', (req, res) => {
    res.end('hello get')
})

app.post('/hello', (req, res) => {
    res.end('hello post')
})
//start server
const server = app.listen(PORT, () => {
    console.log(`Express Web Server is running at ${server.address().port}`)
})
.....................................................................................
			Multi middlewares /Middleware chain
.....................................................................................

We can have n-number of middlewares,order of execution how we have registered.

const express = require('express')
const app = express()
require('dotenv').config()

const PORT = process.env.PORT || 3000

app.use((req, res, next) => {
    res.set('companyName', 'IBM')
    next()
})

//middleware
app.post('/hello', (req, res, next) => {
    res.set({ 'secret': '222232ssfsfsdf' })
    next() //this is required
})

//route
app.get('/hello', (req, res) => {
    res.end('hello get')
})
app.get('/hai', (req, res) => {
    res.end('hai get')
})
app.post('/hello', (req, res) => {
    res.end('hello post')
})
//start server
const server = app.listen(PORT, () => {
    console.log(`Express Web Server is running at ${server.address().port}`)
})
.....................................................................................
....................................................................................
			Router level middleware
....................................................................................

Middleware is set on Router Object

router.use((req,res,next)=>{
  next()
})
router.use('/url'(req,res,next)=>{
  next()
})
router.get('/url'(req,res,next)=>{
  next()
})

....................................................................................
			Router level middleware
....................................................................................

Middleware is set on Router Object

router.use((req,res,next)=>{
  next()
})
router.use('/url'(req,res,next)=>{
  next()
})
router.get('/url'(req,res,next)=>{
  next()
})

const express = require('express')
const customerServicce = require('../services/customer.service')
//create Router Object
const customerRouter = express.Router()

customerRouter.use((req, res, next) => {
    console.log('customerRouter is called')
    next()
})

//apis - get,getById,save,delete,update
//api/customers/
customerRouter.get('/', async (req, res) => {
    try {
        const users = await customerServicce.findAll();
        res.json(users)
    }
    catch (err) {
        res.json({ err: err })
    }
})

customerRouter.get('/:id', async (req, res) => {
    try {
        const id = parseInt(req.params.id)
        const customer = await customerServicce.findById(id);
        if (customer) {
            return res.json(customer)
        }
        return res.status(500).json({ err: `Requestd Customer ${id} Not Found` })

    }
    catch (err) {
        res.json({ err: err })
    }
})
customerRouter.post('/', (req, res) => {
    try {
        let customer = ''
        req.on('data', (chunk) => {
            customer += chunk
        })
        req.on('end', async () => {
            const customerObj = JSON.parse(customer)
            const users = await customerServicce.save(customerObj)
            return res.status(201).json(users)
        })
    }
    catch (err) {
        res.json({ err: err })
    }
})


customerRouter.post('/', async (req, res) => {
    try {
        const user = await customerServicce.save();
        res.json(user)
    }
    catch (err) {
        res.json({ err: err })
    }
})


module.exports = customerRouter
.....................................................................................
		  Can we pass parameters to the Middleware so that we can 
		     configure middleware - Configurable Middlewares
....................................................................................
Middleware which takes parameter , it should be higher order function. - function should return another function.

inner function is middleware.

Syntax: without explicit parameter

app.use(function(req,res,next)=>{})

Syntax: with explicit parameter

const mymiddleware = function(param) {

  return function(req,res,next){
     //access param

    next()
  }
}
app.use(mymiddleware('param'))


eg:

const myMiddleware = function (param) {
    //return function
    return function (req, res, next) {
        console.log('Got Param', param)
        next()
    }
}

app.use(myMiddleware('Marsh'))

.....................................................................................
.....................................................................................
				Types of Middlewares
.....................................................................................
1.Application middleware
2.Router level middleware
3.Error handling middleware
4.Third party middleware


1.Application middleware:
  Middleware is attached on application object

2.Router level middlware

->writing router:

 In express except ,request and response , all features including router is middleware.
 Router is in built middleware.

src/app.js
const express = require('express')
const customerRouter = require('./router/customer.router')
const app = express();

//register middleware 
app.use('/api/customers', customerRouter)

//api - based on resources - customer,products,payments


app.listen(3000, () => {
    console.log('Express server is running')
})

src/app/router/customer.router.js
const express = require('express')
const customerRouter = express.Router()

//middleware
customerRouter.use(function (req, res, next) {
    console.log('customer global middleware')
    next()
})
customerRouter.get('/', function (req, res, next) {
    console.log('customer get middleware')
    res.set({
        'customer': 'CUSTOMER GET'
    })
    next()
})

//api 
customerRouter.get('/', (req, res) => {
    res.json({ message: 'CUSTOMERS' })
})
customerRouter.post('/', (req, res) => {
    res.json({ message: 'customers post' })
})

module.exports = customerRouter

				Error Handling middleware
.....................................................................................

To handle error we have error handling middleware.


Error handling middleware takes four args instead of three arg.

app.use((err, req, res, next)=> {
    //handle error 
     console.err(err.message)
    //send error report to the user
    res.status(500).send('something went wrong')
})


const express = require('express')
const app = express();

app.use((err, req, res, next) => {
    //  next()
    res.status(500);
    res.send('Internal Server Error');
})

//api test error 
app.get('/api/greet/:message', (req, res) => {
    const message = req.params.message
    if (message === 'hello') {
        res.send(message)
    } else {
        throw new Error('Broken...')
    }
})

app.listen(3000, () => {
    console.log('Express server is running')
})
.....................................................................................
...................................................................................
			Built in and third party middlewares
...................................................................................
Built in middleware or third party middlewares

Middlewares are supplied as part of the express team, open source community.
https://expressjs.com/en/resources/middleware.html

in order to parse the incoming payload into javascript object.

Built in middleware or third party middlewares

Middlewares are supplied as part of the express team, open source community.


in order to parse the incoming payload into javascript object.

body-parser:

Node.js body parsing middleware.

Parse incoming request bodies in a middleware before your handlers, available under the req.body property.

.....................................................................................
...................................................................................
			Built in and third party middlewares
...................................................................................
Built in middleware or third party middlewares

Middlewares are supplied as part of the express team, open source community.
https://expressjs.com/en/resources/middleware.html

in order to parse the incoming payload into javascript object.

Built in middleware or third party middlewares

Middlewares are supplied as part of the express team, open source community.


in order to parse the incoming payload into javascript object.

body-parser:

Node.js body parsing middleware.

Parse incoming request bodies in a middleware before your handlers, available under the req.body property.

Steps

1.install middleware
 npm install body-parser

2.require in the code
 const bodyParser = require('body-parser')

app.js
require('dotenv').config()
const express = require('express')
const app = express()
const bodyParser = require('body-parser')

const PORT = process.env.PORT || 3000

//register bodyparserMiddleware
app.use(bodyParser.json())


app.use('/api/users', require('./routers/users/user.router'))


app.get('/', (req, res) => {
    res.end('Home Page')
})


//start server
const server = app.listen(PORT, () => {
    console.log(server.address())
    console.log(`Express is running @ ${server.address().port}`)
})

router/user.js
const express = require('express')
const { findAll, findById, save } = require('../../services/user.service')

//create Router
const UserRouter = express.Router()

//UserRouter middleware
UserRouter.use((req, res, next) => {
    console.log("User Router Globale Middleware")
    next()
})
UserRouter.post('/', (req, res, next) => {
    console.log("User Router Post Middleware")
    next()
})
//api
UserRouter.get('/', async (req, res) => {
    try {
        const users = await findAll();
        res.json(users)
    }
    catch (err) {
        res.json({ err: err })
    }
})

UserRouter.get('/:id', async (req, res) => {
    const id = parseInt(req.params.id)
    try {
        const user = await findById(id);
        if (!user) {
            return res.json({ messgae: 'User Not Found' })
        }
        res.json(user)
    }
    catch (err) {
        res.json({ err: err })
    }
})

//here code receives input as plain string, not json standard string
// UserRouter.post('/', async (req, res) => {
//     try {
//         let data = ''
//         req.on('data', (chunk) => {
//             data += chunk
//         })
//         req.on('end', async () => {
//             const user = await save(data);
//             res.json(user)
//         })
//     }
//     catch (err) {
//         res.json({ err: err })
//     }
// })

UserRouter.post('/', async (req, res) => {
    try {
        const user = req.body
        console.log(user)
        const response = await save(user);
        res.json(response)
    }
    catch (err) {
        res.json({ err: err })
    }
})
..............................................................................................
				 Logger
............................................................................................

In Express, we have many logger implementation ...

morgan:
   HTTP request logger middleware for node.js

How to use Morgan

Steps:

npm install morgan


configuration:

const express = require('express');
require('dotenv').config()
const morgan = require('morgan')
const fs = require('node:fs')
const path = require('node:path')
const PORT = process.env.PORT || 3000
const app = express()


const accessLogStream = fs.createWriteStream(path.join(__dirname, 'access.log'), { flags: 'a' })
//register logger
// app.use(morgan(':method :url :status :res[content-length] - :response-time ms'))
app.use(morgan('combined', { stream: accessLogStream }))

app.use('/api/customers', require('./routers/customer.router'))
app.use('/api/products', require('./routers/products.router'))

const server = app.listen(PORT, () => {
    console.log(server.address())
    console.log(`Express server is running @ ${server.address().port}`)
});
............................................................................................
			  Database Integration
.........................................................................................
.....................................................................................
			  Database Integration
.....................................................................................

Express can integrate sql and no sql databases, provided database drivers.

sql databases:
1.microsoft sql server
2.MySql
3.Postgress SQL
4.Oracle
etc...

NoSql
1.Mongodb
2.redis
3.neo4j
etc...

.....................................................................................
			ORM and ODM
.....................................................................................

ORM - Object relational mapping for sql databases
ODM - Object Document Mapping for nosql-Mongodb

ORM framworks for node.js
1.Prisma
3.sequelize
2.typeorm
etc...

ODM framework for Mongodb:
.........................

1.mongoose -https://mongoosejs.com/docs/
2.Prisma 

Set up Prisma framework:
........................

Relational databases

Prerequisites
1.an existing Node.js project with a package.json

2.Node.js installed on your machine

3.A database server running and a database with at least one table
  (we are going sqlite db)


create project with all dependency:

 Note: we are going to use in-memory database called sqlite.

Steps:
G:\IBM\2024\Oct\NodeJs\prismaSQL>npm init --yes

npm i express body-parser
npm i nodemon --save-dev
npm install prisma --save-dev

npx prisma

Prisma is a modern DB toolkit to query, migrate and model your database (https://prisma.io)

Usage

  $ prisma [command]

Commands

            init   Set up Prisma for your app
        generate   Generate artifacts (e.g. Prisma Client)
              db   Manage your database schema and lifecycle
         migrate   Migrate your database
          studio   Browse your data with Prisma Studio
        validate   Validate your Prisma schema
          format   Format your Prisma schema
         version   Displays Prisma version info
           debug   Displays Prisma debug info

Flags

npx prisma init

creates a new directory called prisma that contains a file called schema.prisma, which contains the Prisma schema with your database connection variable and schema models
creates the .env file in the root directory of the project, which is used for defining environment variables (such as your database connection)


npx prisma init --datasource-provider sqlite

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

.env
PORT=3000

# This was inserted by `prisma init`:
# Environment variables declared in this file are automatically made available to Prisma.
# See the documentation for more detail: https://pris.ly/d/prisma-schema#accessing-environment-variables-from-the-schema

# Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.
# See the documentation for all the connection string options: https://pris.ly/d/connection-strings

DATABASE_URL="file:./dev.db"
....................................................................................
				connect db
....................................................................................

Already we have connection string defined in ".env" file and provider in prisma.schema
.....................................................................................
				Prisma client

Prima client is object which is responsible for talking to database ,

which provides apis for all database operations - CURD operations

npm install @prisma/client

.....................................................................................
				Define model(Entity)
....................................................................................

Model represents table in database.

1.Represent the entities of your application domain
2.Map to the tables (relational databases like PostgreSQL) or collections (MongoDB)   in your database
3.Form the foundation of the queries available in the generated Prisma Client API
4.When used with TypeScript, Prisma Client provides generated type definitions for  your models and any variations of them to make database access entirely type safe.




// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

//define model - describe table structure;database independant
//User is mapped against table
model User {
  // fields- columns
  id    Int     @id @default(autoincrement())
  name  String?
  email String  @unique
}


Database Migration step:

Which creates scripts

npx prisma migrate dev

Environment variables loaded from .env
Prisma schema loaded from prisma\schema.prisma
Datasource "db": SQLite database "dev.db" at "file:./dev.db"

SQLite database dev.db created at file:./dev.db

√ Enter a name for the new migration: ... mymigration
Applying migration `20240209080353_mymigration`

The following migration(s) have been created and applied from new schema changes:

migrations/
  └─ 20240209080353_mymigration/
    └─ migration.sql

Your database is now in sync with your schema.

✔ Generated Prisma Client (v5.9.1) to .\node_modules\@prisma\client in 64ms


Testing :
 Whether all tables are created inside db or not

>npx prisma studio

.................................................................................
			Prisma Client and CURD operations
...................................................................................

Create Prisma client Object

src/routers/user.router.js
const userRouter = require('express').Router();
const { PrismaClient } = require('@prisma/client')


//create prisma object 
const prisma = new PrismaClient()
//expose api
userRouter.get('/', async (req, res) => {
    try {
        const users = await prisma.user.findMany()
        res.status(200).json(users)
    }
    catch (err) {
        res.status(400).json({ message: err.message })
    }

})
userRouter.post('/', async (req, res) => {
    try {
        const newUser = req.body
        if (newUser) {
            const user = await prisma.user.create({
                data: {
                    email: newUser.email,
                    name: newUser.name
                }
            })
            res.status(201).location("/api/users/save").json(user)
        }
    }
    catch (err) {
        res.status(400).json({ message: err.message })
    }
})
userRouter.get('/:id', async (req, res) => {
    const id = Number(req.params.id)
    try {
        const user = await prisma.user.findUnique({
            where: {
                //id: id
                id
            },
        })
        if (user == null) {
            res.status(401).json({ message: `User not found for ID ${id}` })
        }
        res.status(200).json(user)
    }
    catch (err) {
        res.status(400).json({ message: err.message })
    }
})
userRouter.put('/:id', async (req, res) => {
    try {
        const id = Number(req.params.id)
        const user = req.body
        //update 
        const updateUser = await prisma.user.update({
            where: {
                id: id
            },
            data: {
                name: user.name,
                email: user.email
            }
        })
        if (updateUser) {
            res.status(200).json(updateUser)
        } else {
            res.status(401).json({ message: `Update failed for ${id}` })
        }
    }
    catch (err) {
        res.status(400).json({ message: err.message })
    }
})

userRouter.delete('/:id', async (req, res) => {
    const id = Number(req.params.id)
    try {
        const user = await prisma.user.findUnique({
            where: {
                //id: id
                id
            },
        })
        if (user == null) {
            res.status(401).json({ message: `User not found for ID ${id}` })
        } else {
            await prisma.user.delete({
                where: {
                    id
                },
            })
            res.status(204).end()
        }


    }
    catch (err) {
        res.status(400).json({ message: err.message })
    }
})

module.exports = userRouter

src/app.js
const express = require('express')
const app = express()
const bodyParser = require('body-parser')
const PORT = process.env.PORT || 3000

app.use(bodyParser.json())

app.use('/api/users', require('./routers/user.router'))

const server = app.listen(PORT, () => {
    console.log(server.address())
    console.log(`Express is running @ ${server.address().port}`)
})

....................................................................................










